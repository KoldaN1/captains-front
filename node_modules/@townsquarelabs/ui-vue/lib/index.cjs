"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const ui = require("@tonconnect/ui");
const vue = require("vue");
class TonConnectUIVueError extends ui.TonConnectUIError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, TonConnectUIVueError.prototype);
  }
}
class TonConnectProviderNotSetError extends TonConnectUIVueError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype);
  }
}
function checkProvider(provider) {
  if (!provider) {
    throw new TonConnectProviderNotSetError(
      "You should add <TonConnectUIProvider> on the top of the app to use TonConnect"
    );
  }
  return true;
}
function isClientSide() {
  return typeof window !== "undefined";
}
function isServerSide() {
  return !isClientSide();
}
function useTonConnectUI() {
  const tonConnectUI = vue.inject("tonConnectUI");
  const setOptions = (options) => {
    if (tonConnectUI) {
      tonConnectUI.uiOptions = options;
    }
  };
  if (isServerSide()) {
    return [null, () => {
    }];
  }
  checkProvider(tonConnectUI);
  return [tonConnectUI, setOptions];
}
const _sfc_main$1 = vue.defineComponent({
  name: "TonConnectButton",
  props: {
    buttonRootId: {
      type: String,
      required: false,
      default: "ton-connect-button"
    },
    className: {
      type: String,
      required: false
    },
    styles: {
      type: Object,
      required: false
    }
  },
  setup(props, { slots }) {
    const [_, setOptions] = useTonConnectUI();
    console.log("setup", "TonConnectButton");
    vue.onMounted(() => {
      setOptions({ buttonRootId: props.buttonRootId });
    });
    vue.onBeforeUnmount(() => {
      setOptions({ buttonRootId: null });
    });
    return () => {
      var _a;
      return vue.h(
        "div",
        {
          class: props.className,
          id: props.buttonRootId || "",
          attrs: {
            id: props.buttonRootId || ""
          },
          style: { width: "fit-content", ...props.styles }
        },
        (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)
      );
    };
  }
});
const _sfc_main = vue.defineComponent({
  name: "TonConnectUIProvider",
  props: {
    options: {
      type: Object
    }
  },
  setup(props, { slots }) {
    console.log("setup");
    const tonConnectUI = vue.ref(null);
    if (isClientSide() && !tonConnectUI.value) {
      tonConnectUI.value = new ui.TonConnectUI(props.options);
    }
    vue.provide("tonConnectUI", tonConnectUI.value);
    console.log("provide");
    return () => {
      return vue.h(
        "div",
        slots.default ? slots.default() : "nothing"
      );
    };
  },
  render() {
    return vue.h(
      "div",
      this.$slots.default ? this.$slots.default() : "nothing"
    );
  }
});
function useTonWallet() {
  const [tonConnectUI] = useTonConnectUI();
  const wallet = vue.ref(
    (tonConnectUI == null ? void 0 : tonConnectUI.wallet) || null
  );
  const updateWallet = (value) => {
    wallet.value = value;
  };
  vue.onMounted(() => {
    if (tonConnectUI) {
      wallet.value = tonConnectUI.wallet;
      const unsubscribe = tonConnectUI.onStatusChange((value) => {
        updateWallet(value);
      });
      vue.onUnmounted(() => {
        unsubscribe();
      });
    }
  });
  return wallet;
}
function useTonAddress(userFriendly = true) {
  const wallet = useTonWallet();
  const tonAddress = vue.ref("");
  const updateTonAddress = () => {
    if (wallet.value) {
      tonAddress.value = userFriendly ? ui.toUserFriendlyAddress(
        wallet.value.account.address,
        wallet.value.account.chain === ui.CHAIN.TESTNET
      ) : wallet.value.account.address;
    } else {
      tonAddress.value = "";
    }
  };
  vue.watchEffect(() => {
    updateTonAddress();
  });
  return tonAddress;
}
function useTonConnectModal() {
  const [tonConnectUI] = useTonConnectUI();
  const state = vue.ref((tonConnectUI == null ? void 0 : tonConnectUI.modal.state) || null);
  vue.onMounted(() => {
    if (tonConnectUI) {
      state.value = tonConnectUI.modal.state;
      tonConnectUI.onModalStateChange((value) => {
        state.value = value;
      });
    }
  });
  return {
    state,
    open: () => tonConnectUI == null ? void 0 : tonConnectUI.modal.open(),
    close: () => tonConnectUI == null ? void 0 : tonConnectUI.modal.close()
  };
}
function useIsConnectionRestored() {
  const restored = vue.ref(false);
  const [tonConnectUI] = useTonConnectUI();
  vue.onMounted(() => {
    if (tonConnectUI) {
      tonConnectUI.connectionRestored.then(() => {
        restored.value = true;
      });
    }
  });
  return restored;
}
exports.TonConnectButton = _sfc_main$1;
exports.TonConnectProviderNotSetError = TonConnectProviderNotSetError;
exports.TonConnectUIProvider = _sfc_main;
exports.TonConnectUIVueError = TonConnectUIVueError;
exports.useIsConnectionRestored = useIsConnectionRestored;
exports.useTonAddress = useTonAddress;
exports.useTonConnectModal = useTonConnectModal;
exports.useTonConnectUI = useTonConnectUI;
exports.useTonWallet = useTonWallet;
Object.keys(ui).forEach((k) => {
  if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
    Object.defineProperty(exports, k, {
      enumerable: true,
      get: () => ui[k]
    });
});
