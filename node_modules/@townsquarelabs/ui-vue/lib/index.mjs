import { TonConnectUIError, TonConnectUI, toUserFriendlyAddress, CHAIN } from "@tonconnect/ui";
export * from "@tonconnect/ui";
import { inject, defineComponent, onMounted, onBeforeUnmount, h, ref, provide, onUnmounted, watchEffect } from "vue";
class TonConnectUIVueError extends TonConnectUIError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, TonConnectUIVueError.prototype);
  }
}
class TonConnectProviderNotSetError extends TonConnectUIVueError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype);
  }
}
function checkProvider(provider) {
  if (!provider) {
    throw new TonConnectProviderNotSetError(
      "You should add <TonConnectUIProvider> on the top of the app to use TonConnect"
    );
  }
  return true;
}
function isClientSide() {
  return typeof window !== "undefined";
}
function isServerSide() {
  return !isClientSide();
}
function useTonConnectUI() {
  const tonConnectUI = inject("tonConnectUI");
  const setOptions = (options) => {
    if (tonConnectUI) {
      tonConnectUI.uiOptions = options;
    }
  };
  if (isServerSide()) {
    return [null, () => {
    }];
  }
  checkProvider(tonConnectUI);
  return [tonConnectUI, setOptions];
}
const _sfc_main$1 = defineComponent({
  name: "TonConnectButton",
  props: {
    buttonRootId: {
      type: String,
      required: false,
      default: "ton-connect-button"
    },
    className: {
      type: String,
      required: false
    },
    styles: {
      type: Object,
      required: false
    }
  },
  setup(props, { slots }) {
    const [_, setOptions] = useTonConnectUI();
    console.log("setup", "TonConnectButton");
    onMounted(() => {
      setOptions({ buttonRootId: props.buttonRootId });
    });
    onBeforeUnmount(() => {
      setOptions({ buttonRootId: null });
    });
    return () => {
      var _a;
      return h(
        "div",
        {
          class: props.className,
          id: props.buttonRootId || "",
          attrs: {
            id: props.buttonRootId || ""
          },
          style: { width: "fit-content", ...props.styles }
        },
        (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)
      );
    };
  }
});
const _sfc_main = defineComponent({
  name: "TonConnectUIProvider",
  props: {
    options: {
      type: Object
    }
  },
  setup(props, { slots }) {
    console.log("setup");
    const tonConnectUI = ref(null);
    if (isClientSide() && !tonConnectUI.value) {
      tonConnectUI.value = new TonConnectUI(props.options);
    }
    provide("tonConnectUI", tonConnectUI.value);
    console.log("provide");
    return () => {
      return h(
        "div",
        slots.default ? slots.default() : "nothing"
      );
    };
  },
  render() {
    return h(
      "div",
      this.$slots.default ? this.$slots.default() : "nothing"
    );
  }
});
function useTonWallet() {
  const [tonConnectUI] = useTonConnectUI();
  const wallet = ref(
    (tonConnectUI == null ? void 0 : tonConnectUI.wallet) || null
  );
  const updateWallet = (value) => {
    wallet.value = value;
  };
  onMounted(() => {
    if (tonConnectUI) {
      wallet.value = tonConnectUI.wallet;
      const unsubscribe = tonConnectUI.onStatusChange((value) => {
        updateWallet(value);
      });
      onUnmounted(() => {
        unsubscribe();
      });
    }
  });
  return wallet;
}
function useTonAddress(userFriendly = true) {
  const wallet = useTonWallet();
  const tonAddress = ref("");
  const updateTonAddress = () => {
    if (wallet.value) {
      tonAddress.value = userFriendly ? toUserFriendlyAddress(
        wallet.value.account.address,
        wallet.value.account.chain === CHAIN.TESTNET
      ) : wallet.value.account.address;
    } else {
      tonAddress.value = "";
    }
  };
  watchEffect(() => {
    updateTonAddress();
  });
  return tonAddress;
}
function useTonConnectModal() {
  const [tonConnectUI] = useTonConnectUI();
  const state = ref((tonConnectUI == null ? void 0 : tonConnectUI.modal.state) || null);
  onMounted(() => {
    if (tonConnectUI) {
      state.value = tonConnectUI.modal.state;
      tonConnectUI.onModalStateChange((value) => {
        state.value = value;
      });
    }
  });
  return {
    state,
    open: () => tonConnectUI == null ? void 0 : tonConnectUI.modal.open(),
    close: () => tonConnectUI == null ? void 0 : tonConnectUI.modal.close()
  };
}
function useIsConnectionRestored() {
  const restored = ref(false);
  const [tonConnectUI] = useTonConnectUI();
  onMounted(() => {
    if (tonConnectUI) {
      tonConnectUI.connectionRestored.then(() => {
        restored.value = true;
      });
    }
  });
  return restored;
}
export {
  _sfc_main$1 as TonConnectButton,
  TonConnectProviderNotSetError,
  _sfc_main as TonConnectUIProvider,
  TonConnectUIVueError,
  useIsConnectionRestored,
  useTonAddress,
  useTonConnectModal,
  useTonConnectUI,
  useTonWallet
};
